{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PushToTalkButton = void 0;\nvar react_1 = __importStar(require(\"react\"));\nvar react_client_1 = require(\"@speechly/react-client\");\nvar pubsub_js_1 = __importDefault(require(\"pubsub-js\"));\nvar types_1 = require(\"../types\");\nvar HintCallout_1 = require(\"./HintCallout\");\nrequire(\"@speechly/browser-ui/holdable-button\");\nvar PushToTalkButton = function (_a) {\n  var captureKey = _a.captureKey,\n    _b = _a.size,\n    size = _b === void 0 ? '6.0rem' : _b,\n    _c = _a.gradientStops,\n    gradientStops = _c === void 0 ? ['#15e8b5', '#4fa1f9'] : _c;\n  var _d = react_client_1.useSpeechContext(),\n    speechState = _d.speechState,\n    toggleRecording = _d.toggleRecording,\n    initialise = _d.initialise;\n  var _e = react_1.useState(react_client_1.SpeechState.Idle),\n    icon = _e[0],\n    setIcon = _e[1];\n  var buttonRef = react_1.useRef();\n  var speechStateRef = react_1.useRef();\n  // make stateRef always have the current count\n  // your \"fixed\" callbacks can refer to this object whenever\n  // they need the current value.  Note: the callbacks will not\n  // be reactive - they will not re-run the instant state changes,\n  // but they *will* see the current value whenever they do run\n  speechStateRef.current = speechState;\n  react_1.useEffect(function () {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (buttonRef === null || buttonRef === void 0 ? void 0 : buttonRef.current) {\n      var button = buttonRef.current;\n      button.onholdstart = tangentPressAction;\n      button.onholdend = tangentReleaseAction;\n    }\n  });\n  // Change button face according to Speechly states\n  react_1.useEffect(function () {\n    setIcon(speechState);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [speechState]);\n  var tangentPressAction = function () {\n    pubsub_js_1.default.publish(types_1.SpeechlyUiEvents.TangentPress, {\n      state: speechStateRef.current\n    });\n    switch (speechStateRef.current) {\n      case react_client_1.SpeechState.Idle:\n      case react_client_1.SpeechState.Failed:\n        // Speechly & Mic initialise needs to be in a function triggered by event handler\n        // otherwise it won't work reliably on Safari iOS as of 11/2020\n        initialise().catch(function (err) {\n          return console.error('Error initiasing Speechly', err);\n        });\n        break;\n      case react_client_1.SpeechState.Ready:\n        toggleRecording().catch(function (err) {\n          return console.error('Error while starting to record', err);\n        });\n        break;\n      default:\n        break;\n    }\n  };\n  var tangentReleaseAction = function (e) {\n    pubsub_js_1.default.publish(types_1.SpeechlyUiEvents.TangentRelease, {\n      state: speechStateRef.current,\n      timeMs: e.timeMs\n    });\n    switch (speechStateRef.current) {\n      case react_client_1.SpeechState.Recording:\n        toggleRecording().catch(function (err) {\n          return console.error('Error while stopping recording', err);\n        });\n        break;\n      default:\n        break;\n    }\n  };\n  return react_1.default.createElement(\"div\", null, react_1.default.createElement(\"holdable-button\", {\n    ref: buttonRef,\n    capturekey: captureKey,\n    icon: icon,\n    size: size,\n    gradientstop1: gradientStops[0],\n    gradientstop2: gradientStops[1]\n  }), react_1.default.createElement(HintCallout_1.HintCallout, null));\n};\nexports.PushToTalkButton = PushToTalkButton;","map":{"version":3,"names":["react_1","__importStar","require","react_client_1","pubsub_js_1","__importDefault","types_1","HintCallout_1","PushToTalkButton","_a","captureKey","_b","size","_c","gradientStops","_d","useSpeechContext","speechState","toggleRecording","initialise","_e","useState","SpeechState","Idle","icon","setIcon","buttonRef","useRef","speechStateRef","current","useEffect","button","onholdstart","tangentPressAction","onholdend","tangentReleaseAction","default","publish","SpeechlyUiEvents","TangentPress","state","Failed","catch","err","console","error","Ready","e","TangentRelease","timeMs","Recording","createElement","ref","capturekey","gradientstop1","gradientstop2","HintCallout","exports"],"sources":["../../src/components/PushToTalkButton.tsx"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}